{\rtf1\ansi\ansicpg1252\deff0{\fonttbl{\f0\fnil\fcharset0 Segoe UI;}}
{\colortbl ;\red0\green0\blue255;}
{\*\generator Msftedit 5.41.21.2510;}\viewkind4\uc1\pard\ri-1800\sl240\slmult1\lang9\b\f0\fs48 Brief introduction\par
\b0\fs22\par
\b   This game engine aims to provides a simpler interface with more complex systems.\par
This engine provides APIs for rendering, physics, resource mangement, scene management, input, timing and random number generation.\par
\par
\par
\par
\fs48 Resource management\par
\fs22\par
Initiate must be called before using the management system.\par
\cf1\fs24 void  ResourceManager :: Initiate( void );\par
\cf0\fs22\par
\par
\par
\par
\fs36 Loading a resource from a file.\par
\fs22\par
Load an ".obj" wavefront model file.\par
\cf1 bool  \fs24 ResourceManager :: \fs22 LoadWaveFront( std::string filename, std::string resourceName );\par
\cf0\par
Load a ".png" texture file.\par
\cf1 bool  \fs24 ResourceManager :: \fs22 LoadTexture( std::string filename, std::string resourceName );\par
\cf0\par
Load a ".shader" GLSL shader program.\par
\cf1 bool  \fs24 ResourceManager :: \fs22 LoadShaderGLSL( std::string path, std::string resourceName );\par
\cf0\par
\par
\par
\par
\fs36 Finding a loaded resource.\par
\fs22\par
Find and return a loaded mesh resource.\par
\cf1 MeshTag*  \fs24 ResourceManager :: \fs22 FindMeshTag( std::string name );\par
\par
\cf0 Find and return a loaded texture resource.\par
\cf1 TextureTag*  \fs24 ResourceManager :: \fs22 FindTextureTag( std::string name );\par
\par
\cf0 Find and return a loaded GLSL shader resource.\par
\cf1 ShaderTag*  \fs24 ResourceManager :: \fs22 FindShaderTag( std::string name );\par
\cf0\par
Find and return a loaded collision shape resource.\par
\cf1 ColliderTag*  \fs24 ResourceManager :: \fs22 FindColliderTag( std::string name );\par
\cf0\par
\par
\par
\par
\fs36 Creating components from loaded resources.\par
\fs22\par
Create a mesh component for the renderer from a loaded mesh resource.\par
\cf1 Mesh*  \fs24 ResourceManager :: \fs22 CreateMeshFromTag( std::string name );\par
\par
\cf0 Create a material component for the renderer from a loaded texture resource.\par
\cf1 Material*  \fs24 ResourceManager :: \fs22 CreateMaterialFromTag( std::string name );\par
\par
\cf0 Create a shader component for the renderer from a loaded shader resource.\par
\cf1 Shader*  \fs24 ResourceManager :: \fs22 CreateShaderFromTag( std::string name );\par
\cf0\par
Get a physics collider from a loaded collision resource.\par
\cf1 rp3d::BoxShape*  \fs24 ResourceManager :: \fs22 GetColliderFromTag( std::string name );\par
\cf0\par
\par
\par
\par
\fs36 Freeing a resource.\par
\fs22\par
Unload and free a loaded mesh resource.\cf1\par
bool  \fs24 ResourceManager :: \fs22 UnloadMeshTag( std::string name );\par
\par
\cf0 Unload and free a loaded texture resource.\par
\cf1 bool  \fs24 ResourceManager :: \fs22 UnloadTextureTag( std::string name );\par
\par
\cf0 Unload and free a loaded shader resource.\par
\cf1 bool  \fs24 ResourceManager :: \fs22 UnloadShaderTag( std::string name );\par
\cf0\par
Clear all loaded assets and any memory allocated therein.\par
\cf1 void  \fs24 ResourceManager :: \fs22 DestroyAssets( void );\par
\cf0\par
\par
\par
\par
\par
\fs48 Rendering system\par
\fs22\par
Initiate must be called before the renderer can be used.\cf1\par
void  RenderSystem :: Initiate( void );\par
\par
\par
\par
\cf0 Mesh objects handle vertex buffers and layout.\cf1\par
Mesh* RenderSystem :: CreateMesh( void );\par
bool     RenderSystem :: DestroyMesh( Mesh* meshPtr );\par
\par
\cf0 Materials handle texture layout and color effects.\cf1\par
Material* RenderSystem :: CreateMaterial( void );\par
bool          RenderSystem :: DestroyMaterial( Material* materialPtr );\par
\par
\cf0 Shader objects handle shader compilation.\cf1\par
Shader* RenderSystem :: CreateShader( void );\par
bool       RenderSystem :: DestroyShader( Shader* shaderPtr );\par
\par
\cf0 Entities transform rendering components.\cf1\par
Entity* RenderSystem :: CreateEntity( void );\par
bool     RenderSystem :: DestroyEntity( Entity* entityPtr );\par
\par
\cf0 Scene objects organize and group entities for rendering.\cf1\par
Scene* RenderSystem :: CreateScene( void );\par
Scene* RenderSystem :: GetScene( unsigned int index );\par
unsigned int  RenderSystem :: GetSceneCount( void );\par
bool     RenderSystem :: DestroyScene( Scene* scenePtr );\par
\par
\cf0 Camera objects provide a projection angle for the rendering process.\cf1\par
Camera* RenderSystem :: CreateCamera( void );\par
bool        RenderSystem :: DestroyCamera( Camera* cameraPtr );\par
\par
\cf0 Sky objects provide a rendering backdrop.\cf1\par
Sky*  RenderSystem :: CreateSky( void );\par
bool  RenderSystem :: DestroySky( Sky* skyPtr );\par
\par
\cf0 Scripts provide native scripting.\par
\cf1 Script* RenderSystem :: CreateScript( void );\par
bool     RenderSystem :: DestroyScript( Script* scriptPtr );\par
\par
\par
\par
\par
\cf0\fs36 Renderer functions\par
\fs22\par
Set the dimensions for the rendering viewport.\par
Note: Viewport is NOT the window size. Viewport is the area rendered within the window.\par
\cf1 void  RenderSystem :: SetViewport( unsigned int x, unsigned int y, unsigned int w, unsigned int h );\par
\par
\cf0 Render a frame using the current camera.\par
\cf1 void  RenderSystem :: RenderFrame( float deltaTime );\par
\par
\cf0 The render queue is a list of scenes to be rendered by the renderer.\par
\cf1 void  RenderSystem :: AddToRenderQueue( Scene* scene );\par
bool  RenderSystem :: RemoveFromRenderQueue( Scene* scene );\par
\par
\cf0 Return the number of scenes in the render queue.\par
\cf1 unsigned int  RenderSystem :: GetRenderQueueSize( void );\par
\cf0\par
Return a scene from the render queue at the givin index.\par
\cf1 Scene*  RenderSystem :: GetRenderQueueScene( unsigned int index );\par
\par
\cf0 Calculate the matrix for the model transform.\par
\cf1 glm::mat4  RenderSystem :: CalculateModelMatrix( Transform& model );\par
\cf0\par
\par
\par
\par
\fs36 Setting the window context for rendering\par
\cf1\fs22\par
\cf0 Set the target context for rendering.\par
\cf1 GLenum  RenderSystem :: SetRenderTarget( HWND wHndl );\par
\cf0\par
Release the target context.\par
\cf1 void    RenderSystem :: ReleaseRenderTarget( void );\par
\cf0\par
\par
\par
\par
\fs36 Meshes\par
\fs22\par
Set the primitive drawing type. Default is GL_TRIANGLES.\par
\cf1 void  Mesh :: SetPrimitive( int primitiveType );\par
\cf0\par
Enable and set a given vertex attribute.\par
\cf1 void  Mesh :: SetAttribute( int index, int attributeCount, int vertexSize, int byteOffset );\par
\cf0\par
Disable a vertex attribute.\par
\cf1 void  Mesh :: DisableAttribute( int index );\par
\cf0\par
Set the attributes for the default vertex buffer layout.\par
\cf1 void  Mesh :: SetDefaultAttributes( void );\par
\cf0\par
\par
\par
Add a plain sub mesh to the mesh at the given position and scaled by width and height.\par
The color parameter will assign a color to the plane sub mesh.\par
\cf1 bool  Mesh :: AddPlain( float x, float y, float z, float width, float height, Color color );\par
\cf0\par
Add a wall sub mesh to the mesh at the given position and scaled by width and height.\par
The color parameter will assign a color to the wall sub mesh.\par
\cf1 void  Mesh :: AddWall( float x, float y, float z, float width, float height, Color color );\par
\par
\par
\par
\cf0 Return the number of sub meshes currently loaded into this mesh vertex buffer.\par
\cf1 unsigned int  Mesh :: GetSubMeshCount( void );\par
\par
\cf0 Add a sub mesh to the mesh vertex buffer.\cf1\par
bool  Mesh :: AddSubMesh( float x, float y, float z, SubMesh& mesh );\par
\par
\cf0 Remove a sub mesh from the mesh at the given index.\par
\cf1 bool  Mesh :: RemoveSubMesh( unsigned int index );\par
\cf0\par
Copy the sub mesh at the index location and return a SubMesh containing the vertex data.\par
\cf1 bool  Mesh :: CopySubMesh( unsigned int index, SubMesh& mesh );\par
\cf0\par
\par
\par
Update a sub mesh color to a new color.\par
\cf1 bool  Mesh :: ChangeSubMeshColor( unsigned int index, Color newColor );\par
\cf0\par
Update a sub mesh position to a new position.\par
\cf1 bool  Mesh :: ChangeSubMeshPosition( unsigned int index, float x, float y, float z );\par
\cf0\par
\par
\par
Flushe the mesh buffer to the GPU for rendering.\par
\cf1 bool  Mesh :: UpdateMesh( void );\par
\cf0\par
\par
\par
\par
\fs36 Materials\par
\fs22\par
Enable depth testing.\par
\cf1 void  Material :: EnableDepthTest( void );\par
void  Material :: DisableDepthTest( void );\par
\cf0\par
Set the function the renderer will use to test depth.\par
\cf1 void  Material :: SetDepthFunction(GLint func);\par
\par
\cf0\par
\par
Enable alpha color blending.\par
\cf1 void  Material :: EnableBlending( void );\par
void  Material :: DisableBlending( void );\par
\par
\cf0 Set the blending source and destination.\par
\cf1 void  Material :: SetBlending( GLint src, GLint dest );\par
\cf0\par
Set the blending source and destination with alpha channels.\par
\cf1 void  Material :: SetBlendingAlpha( GLint srca, GLint desta );\par
\cf0\par
Set the function for blending.\par
\cf1 void  Material :: SetBlendingFunction( GLint func );\par
\cf0\par
\par
\par
Enable face culling.\par
\cf1 void  Material :: EnableCulling( void );\par
void  Material :: DisableCulling( void );\par
\cf0\par
Set the side of the triangles where no pixles will be drawn. Default is GL_BACK.\par
\cf1 void  Material :: SetFaceCullingSide( GLint side );\par
\cf0\par
Set the triangle winding order. Default is GL_CCW (counter clock wise) .\par
\cf1 void  Material :: SetFaceWindingOrder( GLint direction );\par
\cf0\par
\par
\par
Flush the texture data to the GPU buffer.\par
\cf1 void  Material :: UpdateTextureBuffer( void* textureData );\par
\cf0\par
\par
\par
\par
\fs36 Shaders\par
\cf1\fs22\par
\cf0 Set the uniform model matrix.\par
\cf1 void  Shader :: SetModelMatrix( glm::mat4 &ModelMatrix );\par
\cf0\par
Set the uniform projection matrix.\par
\cf1 void  Shader :: SetProjectionMatrix( glm::mat4 &projectionMatrix );\par
\par
\cf0\par
\par
Set the uniform material color.\par
\cf1 void  Shader :: SetMaterialColor( Color color );\par
\cf0\par
Set the uniform texture sampler\par
\cf1 void  Shader :: SetTextureSampler( unsigned int index );\par
\cf0\par
\par
\par
Initiate the uniform locations within the shader program.\par
\cf1 void  Shader :: SetUniformLocations( void );\par
\par
\cf0 Compile a vertex and fragment script into a shader program.\par
\cf1 int  Shader :: CreateShaderProgram( std::string VertexScript, std::string FragmentScript );\par
\par
\cf0 Build a default shader program.\par
\cf1 bool  Shader :: BuildDefault( void );\par
\par
\par
\cf0\par
\par
\fs36 Camera\par
\cf1\fs22\par
\cf0 Update the mouse look angle by the givin delta time. The mouse pointer will be reset \par
to the position at mouseResetX and mouseResetY.\par
\cf1 void  Camera :: MouseLook( float deltaTime, int mouseResetX, int mouseResetY );\par
\cf0\par
Enable camera mouse looking.\par
\cf1 void  Camera :: EnableMouseLook( void );\par
\par
\cf0 Disable camera mouse looking.\par
\cf1 void  Camera :: DisableMouseLook( void );\par
\par
\cf0 Set the uniform model matrix.\par
\cf1 void Camera::SetMouseCenter(int mouseResetX, int mouseResetY)\par
\par
\par
\par
\par
\cf0\fs36 Sky\par
\fs22\par
Set the background color.\par
\cf1 void  Sky :: SetColor( Color newColor );\cf0\par
\par
\par
\par
\par
\par
\fs48 Physics System\par
\fs22\par
Initiate must be called before the physics system can be used.\par
\cf1 void Initiate(void);\par
\cf0\par
Rigid bodies simulate physical objects in a 3D space.\par
\cf1 rp3d::RigidBody*  Physics :: CreateRigidBody( float x, float y, float z );\par
void  Physics :: DestroyRigidBody( rp3d::RigidBody* rigidBodyPtr );\par
\cf0\par
World gravity will effect all objects within the world space.\par
\cf1 void  Physics :: SetWorldGravity( float x, float y, float z );\par
\cf0\par
Create collider shapes.\par
\cf1 rp3d::BoxShape*        Physics :: CreateColliderBox(float xscale, float yscale, float zscale);\par
rp3d::SphereShape*   Physics :: CreateColliderSphere(float radius);\par
rp3d::CapsuleShape*  Physics :: CreateColliderCapsule(float radius, float height);\par
\cf0\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\tab\tab Copyright (c) 2023\par
\par
\par
}
 